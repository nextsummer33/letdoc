const puppeteer = require('puppeteer')
const path = require('path')
const sharp = require('sharp')

async function mermaidPipeline(
  mdContent,
  options = {
    config,
    css,
    width: 1000,
    height: 1000,
    deviceScaleFactor: 1,
    imageFormat: false,
  }
) {
  const { config, css, width, height, deviceScaleFactor, imageFormat } = options
  // Get all the mermaid code block in the markdown content
  const mermaidCtx = mdContent.match(/```mermaid *(?:\S+)?(?:\s+)(?:[^`]+)\s*```/g)

  if (mermaidCtx && mermaidCtx.length) {
    // Running a puppeteer and headless chromiumn
    const browser = await puppeteer.launch()
    const page = await browser.newPage()
    page.setViewport({ width, height, deviceScaleFactor })
    await page.goto(`file://${path.join(__dirname, 'index.html')}`)
    await page.evaluate(`document.body.style.background = 'transparent'`)

    for (let i = 0; i < mermaidCtx.length; i++) {
      // extract the context in the mermaid code block
      const ctx = mermaidCtx[i].replace(/```mermaid *(\S+)?(?:\s+)([^`]+)\s*```/, '$2')
      const subMatches = mermaidCtx[i].match(/```mermaid *(\S+)?(?:\s+)([^\s:]+)\s*[^`]*```/)
      const inlineStyle = subMatches[1] ? `style="${subMatches[1].trim()}"` : ''
      const type = subMatches[2]
      // Calling mermaid api to get the rendered svg content.
      let svg = await page.$eval(
        'head',
        function (head, definition, config, css, index) {
          const mermaid = window.mermaid
          mermaid.initialize(config)
          // Added custom css into head section
          if (css) {
            const style = document.createElement('style')
            style.type = 'text/css'
            if (style.styleSheet) {
              style.styleSheet.cssText = css
            } else {
              style.appendChild(document.createTextNode(css))
            }
            head.appendChild(style)
          }
          // render the mermaid diagram via api
          return mermaid.mermaidAPI.render(`mermaid-${index}`, definition)
        },
        ctx,
        config,
        css,
        i + 1
      )
      // Cleanup the svg in a minified formated, remove unncessary space and line break.
      svg = svg.replace(/(\n|\t|\r)*/g, '')
      // Remove an invalid css style that generated by mermaid.
      // E.g.#mermaid - 4.green { !important; }
      // We have to remove that otherwise, the following css will be ignored
      svg = svg.replace(/[\.\w\s\-\#\>\~]*{\s*!important;\s*}/g, '')
      // checking the existent of viewbox attribute
      if (svg.indexOf('viewBox') === -1) {
        const matches = /<svg[^>]+height="(\d+\.\d+)".+/.exec(svg) || []
        let height = matches.length > 1 ? matches[1] : 0
        svg = svg.replace(
          /<svg(.+)/,
          `<svg viewBox="0 0 ${width} ${height}" $1`
        )
      }
      // It causing the svgo mininizer could not parse the svg correctly
      // remove the width attribute, using the default width for svg
      svg = svg.replace(/(<svg[^>]+)width="[\d%px\.]+"(.+)/g, `$1$2`)
      svg = svg.replace(/(<svg[^>]+)height="[\d%px\.]+"(.+)/g, `$1$2`)

      if (imageFormat) {
        const clip = await page.$eval('#container', (container, svg) => {
          container.innerHTML = svg;
          const el = document.querySelector('svg')
          const { left, top, width, height } = el.getBoundingClientRect()
          return {
            x: left,
            y: top,
            width,
            height
          }
        }, svg)

        let buffer = await page.screenshot({clip, encoding: 'binary' })
        buffer = await sharp(buffer)
          .png()
          .toBuffer()
        const base64str = buffer.toString('base64')
        svg = `<img src="data:image/png;base64,${base64str}" />`
      }

      mdContent = mdContent.replace(
        /```mermaid[^`]*```/,
        `<div class="mermaid-container ${type.toLowerCase()}" ${inlineStyle}>${svg}</div>`
      )
    }
  }

  return mdContent
}

module.exports = mermaidPipeline
